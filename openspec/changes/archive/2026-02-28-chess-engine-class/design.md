## Context

Сейчас шахматная логика разбита на stateless-функции в `src/chess/rules.ts` (генерация ходов) и `src/chess/types.ts` (типы + начальная позиция). Состояние доски хранится в компонентах через `useState`. Нет единого объекта, который агенты могли бы использовать для выполнения ходов, проверки легальности и получения позиции в стандартных форматах (FEN/UCI/SAN).

Компонент Arena и AI-агенты нуждаются в императивном API для управления партией — без привязки к React lifecycle.

## Goals / Non-Goals

**Goals:**
- Единый класс `ChessEngine` с полным API для управления партией
- Поддержка FEN (чтение/запись), UCI (ввод ходов), SAN (история)
- Поддержка Chess960 (Fischer Random) при reset
- Валидация ходов через существующую логику `getLegalMoves`
- Хранение истории ходов внутри класса
- Класс — plain TypeScript, без зависимости от React

**Non-Goals:**
- AI/evaluation логика — это ответственность агентов
- Замена существующих компонентов `ChessBoard`/`ChessPiece` — они будут адаптированы отдельно

## Decisions

### 1. Класс вместо функционального модуля

**Выбор:** `class ChessEngine` с мутабельным внутренним состоянием.

**Почему:** Агенты работают в императивном стиле — вызывают методы и получают результаты. Класс инкапсулирует board, turn, move history в одном объекте. Удобно создавать несколько экземпляров для параллельных партий.

**Альтернатива:** Функциональный подход с immutable state — усложняет API для агентов без видимой выгоды.

### 2. Файл `src/chess/engine.ts`

**Выбор:** Новый файл в существующей директории `src/chess/`.

**Почему:** Логически группируется с `types.ts` и `rules.ts`. Импортирует из обоих.

### 3. Расширение `getLegalMoves` до полных правил

**Выбор:** Доработать существующий `rules.ts` — добавить проверку шаха (фильтрация ходов, оставляющих короля под шахом), рокировку, взятие на проходе, превращение пешки. Добавить функции определения шаха, мата, пата.

**Почему:** `getLegalMoves` — единственная точка валидации ходов. Если она неполная, `moveUCI` будет принимать нелегальные ходы. Полные правила нужны для корректной игры агентов.

**Что потребуется:**
- `getLegalMoves` должен принимать дополнительный контекст (castling rights, en passant square) — либо через параметры, либо через объект `GameState`
- Фильтрация pseudo-legal ходов: после каждого кандидата проверяем, не остаётся ли король под шахом
- `isInCheck(board, color)`, `isCheckmate(board, color, gameState)`, `isStalemate(board, color, gameState)`

**Альтернатива:** Оставить rules.ts как есть и сделать полную валидацию внутри engine — но это дублирование логики.

### 4. Расширение типов — `GameState` как центральная модель

**Выбор:** Ввести интерфейс `GameState` в `types.ts`, который объединяет всю информацию из FEN:

```
interface GameState {
  board: Board;
  activeColor: PieceColor;
  castlingRights: { K: boolean; Q: boolean; k: boolean; q: boolean };
  enPassantSquare: number | null;  // target square index или null
  halfmoveClock: number;
  fullmoveNumber: number;
}
```

**Почему:** FEN содержит 6 полей, а не только расстановку фигур. `getLegalMoves` нуждается в `castlingRights` (для рокировки) и `enPassantSquare` (для взятия на проходе). `activeColor` определяет чей ход. Halfmove clock нужен для правила 50 ходов.

**Изменение сигнатуры `getLegalMoves`:** `getLegalMoves(state: GameState, fromIndex: number)` вместо текущего `getLegalMoves(board: Board, fromIndex: number)`. **BREAKING** для существующих вызовов в компонентах — потребуется адаптация `ChessBoard.tsx`.

**Альтернатива:** Оставить `Board` и добавить опциональные параметры — но это засоряет сигнатуру и не гарантирует полноту контекста.

### 5. UCI-парсинг — строка из 4-5 символов

**Выбор:** `moveUCI` принимает строку вида `e2e4` (4 символа) или `e7e8q` (5 символов, для будущего промоушена). Парсит в from/to индексы, проверяет через `getLegalMoves`.

**Почему:** UCI — стандартный формат для коммуникации с шахматными движками. Агенты LLM хорошо знакомы с этим форматом.

### 6. SAN-конвертация — на лету из истории

**Выбор:** `getSAN()` конвертирует внутренний массив `MoveRecord[]` в SAN-нотацию при вызове. Каждый `MoveRecord` хранит: piece, from, to, captured?, и board snapshot до хода.

**Почему:** SAN требует контекст (какая фигура, нужна ли disambiguация). Хранение raw данных и конвертация при запросе — проще и гибче, чем конвертация при записи.

### 7. Chess960 — рандомизация back rank при reset

**Выбор:** `reset(fisher?: boolean)` — при `fisher=true` генерирует случайную позицию back rank по правилам Chess960 (король между ладьями, разноцветные слоны). FEN устанавливается соответственно.

**Почему:** Минимальное изменение — только логика расстановки в `reset`. Все остальные методы работают одинаково.

### 8. Результат moveUCI — Result-паттерн

**Выбор:** `moveUCI` возвращает `{ success: true } | { success: false, error: string }`.

**Почему:** Явный Result-тип без исключений. Агенты могут программно обработать ошибку и попробовать другой ход. Сообщение об ошибке помогает LLM-агенту понять причину.

## Risks / Trade-offs

- **Дублирование состояния**: Arena-компонент сейчас хранит board в useState. При интеграции нужно будет синхронизировать engine.board с React state → Mitigation: Arena будет читать board из engine после каждого хода, engine — single source of truth.

- **Сложность полных правил**: Проверка шаха требует генерации атак противника для каждого кандидатного хода → Mitigation: Простая реализация через "сделать ход → проверить атакован ли король → откатить". Для партий < 200 ходов производительность не проблема.

- **Расширение сигнатуры getLegalMoves**: Для рокировки и en passant нужен дополнительный контекст (castling rights, en passant square) → Mitigation: Ввести `GameState` интерфейс, передавать его в `getLegalMoves`. Обратная совместимость через опциональный параметр.

- **Производительность SAN-конвертации**: `getSAN()` конвертирует всю историю при каждом вызове → Mitigation: Для типичной партии (< 200 ходов) это незначительно. При необходимости можно кешировать.

- **Chess960 валидация**: Начальная позиция Chess960 требует специальных правил рокировки, которые пока не реализованы → Mitigation: Chess960 reset работает, рокировка будет добавлена в следующей итерации.
